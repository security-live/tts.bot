<!DOCTYPE html>
<html lang="en" data-bs-theme="dark">
  <head>
    <title>TTS.bot by Security_Live</title>
    <meta charset="utf-8" />

    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />

    <link
      href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha3/dist/css/bootstrap.min.css"
      rel="stylesheet"
      integrity="sha384-KK94CHFLLe+nY2dmCWGMq91rCGa5gtU4mk92HdvYe+M/SXH301p5ILy+dN9+nJOZ"
      crossorigin="anonymous"
    />

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.0/css/all.min.css" />

    <!-- Custom CSS -->
    <link rel="stylesheet" href="styles.css" />
  </head>
  <body>
    <div class="main-container container-fluid">
      <div class="topHeader row">
          <div class="col-md-2 text-left">
            <!-- Content for the left-aligned div -->
            <div id="title">TTS.bot</div>
          </div>
          <div class="col-8 text-center">
            <!-- Content for the center-aligned div -->
            <!-- Content for the center-aligned div -->
            <label>Channel:</label>
            <input type="text" id="channel" class="bg-dark text-white" value placeholder="Channel" />
            <button type="button" id="btn-go" class="btn btn-dark" onclick="connect()">Go</button>
            <button
              type="button"
              id="btn-stop"
              class="btn btn-dark"
              onclick="location.href='index.html?autoconnect=false';"
            >
              Stop
            </button>
          </div>
          <div class="col-md-2 text-right">
            <!-- Content for the right-aligned div -->
            <span id="status">Disconnected</span
            ><button type="button" id="settings-gear" class="btn btn-default" onclick="toggleSettingsMenu()">
              <i class="fa fa-cog"></i>
            </button>
          </div>
        </div>

      <div class="row settings-menu" id="settingsMenu" style="display: none">
        <!-- Move all settings options here -->

        <!-- The rest of your HTML code remains the same -->

        <div id="loggedin" style="display: none">
          <div id="settings" class="container-fluid">
            <!-- Top Header -->

            <div class="row" style="padding: 20px">
              <div class="col-md-6">
                <div class="form-group">
                  <dt><label for="twitch_username">Token credentials:</label></dt>
                  <dd class="clearfix">
                    <input
                      type="text"
                      id="twitch_username"
                      class="form-control"
                      value
                      placeholder="twitch username"
                      disabled
                    />
                  </dd>
                </div>

                <div id="srcLangPlaceholder" class="form-group"></div>

                <div id="dstLangPlaceholder" class="form-group"></div>

                <div class="form-check">
                  <input class="form-check-input" type="checkbox" id="cbSpeak" onchange="saveCheckbox(event)" value="Speak" checked />
                  <label class="form-check-label" for="cbSpeak">
                    TTS Enabled
                  </label>
                </div>

                <div class="form-check">
                  <input class="form-check-input" type="checkbox" id="cbAutoTranslateChat" onchange="saveCheckbox(event)" />
                  <label class="form-check-label" for="cbAutoTranslateChat">
                    Auto translate chat and output to channel (Be aware this will send translations to any channel connected)
                  </label>
                </div>

                <div class="form-check">
                  <input class="form-check-input" type="checkbox" id="cbDeleteCommands" onchange="saveCheckbox(event)" />
                  <label class="form-check-label" for="cbDeleteCommands">
                    Delete all channel commands that start with !
                  </label>
                </div>

                <div class="form-check">
                  <input class="form-check-input" type="checkbox" id="cbEveryoneTTS" onchange="saveCheckbox(event)" checked />
                  <label class="form-check-label" for="cbEveryoneTTS">
                    Allow Everyone to use TTS
                  </label>
                </div>

                <div class="form-check">
                  <input class="form-check-input" type="checkbox" id="cbModTTS" onchange="saveCheckbox(event)" checked />
                  <label class="form-check-label" for="cbModTTS">
                    Allow Mods to use TTS
                  </label>
                </div>

                <div class="form-check">
                  <input class="form-check-input" type="checkbox" id="cbVipTTS" onchange="saveCheckbox(event)" checked />
                  <label class="form-check-label" for="cbVipTTS">
                    Allow Vips to use TTS
                  </label>
                </div>

                <div class="form-check">
                  <input class="form-check-input" type="checkbox" id="cbSubTTS" onchange="saveCheckbox(event)" checked />
                  <label class="form-check-label" for="cbSubTTS">
                    Allow Subs to use TTS
                  </label>
                </div>

                <div class="form-check">
                  <input class="form-check-input" type="checkbox" id="cbSpeakReplies" onchange="saveCheckbox(event)" />
                  <label class="form-check-label" for="cbSpeakReplies">
                    Speak replies and @name references at start of message.
                  </label>
                </div>

                <div class="form-check d-inline-block">
                  <input class="form-check-input" type="checkbox" id="cbSpeakEmotesTTS" onchange="saveCheckbox(event)" checked />
                  <label class="form-check-label" for="cbSpeakEmotesTTS">
                    Speak emotes
                  </label>
                </div>
                <div class="form-check d-inline-block">
                  <input class="form-check-input" type="checkbox" id="cbDedupEmotesTTS" onchange="saveCheckbox(event)" checked />
                  <label class="form-check-label" for="cbDedupEmotesTTS">
                    Dedup emotes
                  </label>
                </div>

                <div class="form-check">
                  <input class="form-check-input" type="checkbox" id="cbCleanupTranslation" onchange="saveCheckbox(event)" />
                  <label class="form-check-label" for="cbCleanupTranslation">
                    If translation is identical to original message don't translate.
                  </label>
                </div>

                <div class="form-check">
                  <input class="form-check-input" type="checkbox" id="cbUserLevDistance" onchange="saveCheckbox(event)" checked />
                  <label class="form-check-label" for="cbUserLevDistance">
                    Don't speak user message if they are a % similar to the last messages in the last X seconds.
                    (Levenshtein distance)
                  </label>
                </div>
                <label for="txtUserLevPct"
                >Percent:
                  <input
                    style="display: inline-block; width: 75px"
                    type="number"
                    size="5"
                    id="txtUserLevPct"
                    class="form-control"
                    value="90"
                    placeholder="90"
                    oninput="saveTextField(event)"
                  /></label>
                <label for="txtUserLevTime">
                  Time:
                  <input
                    style="display: inline-block; width: 75px"
                    type="number"
                    size="5"
                    id="txtUserLevTime"
                    class="form-control"
                    value="300"
                    placeholder="300"
                    oninput="saveTextField(event)"
                  /></label>

                <div class="form-check">
                  <input class="form-check-input" type="checkbox" id="cbChatLevDistance"
                         onchange="saveCheckbox(event)" checked/>
                  <label class="form-check-label" for="cbChatLevDistance">
                    Don't speak chat messages if they are a % similar to the last messages in the last X seconds.
                    (Levenshtein distance)
                  </label>
                </div>
                <label for="txtChatLevPct"
                >Percent:
                  <input
                    style="display: inline-block; width: 75px"
                    type="number"
                    size="5"
                    id="txtChatLevPct"
                    class="form-control"
                    value="90"
                    placeholder="90"
                    oninput="saveTextField(event)"
                  /></label>
                <label for="txtChatLevTime">
                  Time:
                  <input
                    style="display: inline-block; width: 75px"
                    type="number"
                    size="5"
                    id="txtChatLevTime"
                    class="form-control"
                    value="300"
                    placeholder="300"
                    oninput="saveTextField(event)"
                  /></label>
              </div>

              <div class="col-md-6">
                <div class="form-group">
                  These options require microphone access:<br />
                  <div class="form-check">
                    <input class="form-check-input" type="checkbox" id="cbPauseTTSOnSpeech" onchange="saveCheckbox(event)" checked />
                    <label class="form-check-label" for="cbPauseTTSOnSpeech">
                      Pause TTS when speaking. (Must allow mic access and choose correct mic input)
                    </label>
                  </div>

                  <div class="form-check">
                    <input class="form-check-input" type="checkbox" id="cbPoofMessage" onchange="saveCheckbox(event)" />
                    <label class="form-check-label" for="cbPoofMessage">
                      Say "poof" message to stop speaking a message and continue.
                    </label>
                  </div>
                  <label class="d-block mb-1"><input
                    type="text"
                    size="80"
                    id="txtPoofRegex"
                    class="form-control"
                    value="(poof|proof|poop)"
                    placeholder="example regex: (poof|proof|poop)"
                    onchange="saveTextField(event)"
                  /></label>

                  <div class="form-check">
                    <input class="form-check-input" type="checkbox" id="cbBanHammer" onchange="saveCheckbox(event)" />
                    <label class="form-check-label" for="cbBanHammer">
                      Say "ban" message to stop speaking and speak "ban confirmation" message.
                    </label>
                  </div>
                  <label class="d-block mb-4"><input
                    type="text"
                    size="80"
                    id="txtBanRegex"
                    class="form-control"
                    value="(band hammer|ben hammer|ban hammer|banhammer|ben hammer|jan hammer)"
                    placeholder="example regex: (ben hammer|ban hammer|banhammer|ben hammer|jan hammer)"
                    oninput="saveTextField(event)"
                  /></label>
                  <label class="d-block mb-4"><input
                    type="text"
                    size="80"
                    id="txtBanConfirmRegex"
                    class="form-control"
                    value="(affirmative)"
                    placeholder="example regex: (affirmative)"
                    oninput="saveTextField(event)"
                  /></label>

                  <div class="form-check">
                    <input class="form-check-input" type="checkbox" id="cbSTTS" onchange="saveCheckbox(event)" />
                    <label class="form-check-label" for="cbSTTS">
                      Use Webkit Voice Recognition and speak result in system language and voice. (Must allow mic access and
                      choose correct mic input)
                    </label>
                  </div>

                  <div class="form-check">
                    <input class="form-check-input" type="checkbox" id="cbSendDictationTranslation" onchange="saveCheckbox(event)" />
                    <label class="form-check-label" for="cbSendDictationTranslation">
                      Send Dictation Text and Translation to Channel (Be aware this will send translations to any channel
                      connected)
                    </label>
                  </div>

                  <div class="form-check">
                    <input class="form-check-input" type="checkbox" id="cbSendTextToWebsocket"
                           onchange="saveCheckbox(event); enableCustomWebsocket(this.checked);"
                    />
                    <label class="form-check-label" for="cbSendTextToWebsocket">
                      Send spoken text to websocket for comannds.
                    </label>
                  </div>
                  <label class="d-block mb-4"><input
                    type="text"
                    id="txtWebsocketURL"
                    class="form-control"
                    value="ws://localhost:1880/stt"
                    placeholder="ws://localhost:1880/stt"
                  /></label>

                  <div class="form-check">
                    <input class="form-check-input"
                      type="checkbox"
                      id="cbSendTextToAWSWebsocket"
                      onchange="saveCheckbox(event); enableAWSWebsocket(this.checked);"
                    />
                    <label class="form-check-label" for="cbSendTextToAWSWebsocket">
                      Send spoken text to AWS for end user clients.
                    </label>
                  </div>
                  <label class="d-block mb-4"><input
                    type="text"
                    id="txtAWSWebsocketURL"
                    class="form-control"
                    value="wss://api.tts.bot"
                    placeholder="wss://api.tts.bot"
                  /></label>

                  <a href="node-red-example-command-flow.json">Example Node-RED Command Flow</a>
                </div>

                <div id="systemLangPlaceholder"></div>
                <div id="systemVoicePlaceholder"></div>
                <br />
                <label class="d-block mb-4"><input
                  type="text"
                  id="txtCCTURL"
                  class="form-control"
                  value="https://securitylive.com/translator.html?popup=true&src=en&dst=de&webkit-text-stroke-color=red&outline-color=red&shadow-color=red&border-color=red"
                  placeholder="test"
                /></label>

                <input type="button" value="Open Dictation Window" onclick="OpenPopup()" />
              </div>
            </div>
          </div>
        </div>
      </div>

      <div id="chatContainer" class="row">
        <div class="button-container" id="login"></div>

        <!-- Chat Boxes -->
        <div class="section-chat-boxes">
          <!-- Live Chat -->
          <div class="col-md-12">
            <div class="panel panel-primary">
              <div class="panel-heading panelHeading">Live Chat</div>

              <div class="live-chat-wrapper">
                <div id="livechatc" class="panel-body panelBody">
                  <div class="subscribe" id="livechat"></div>
                </div>
              </div>
            </div>
          </div>
        </div>
        <!-- Live Chat -->

        <!-- Send Message -->
        <div class="section-send-message row mt-auto p-4">
          <div class="col-md-2">
            <div id="chatLangPlaceholder" class="form-group"></div>
          </div>

          <div class="col-md-8">
            <input type="text" id="message" class="form-control" onkeydown="message_key(this)" />
          </div>

          <div class="col-md-2">
            <button
              style="width: 100px"
              type="button"
              class="form-control btn btn-dark"
              id="btn-send"
              onclick="sendMessage()"
            >
              Send
            </button>
          </div>
        </div>
      </div>
    </div>

    <script
      src="https://code.jquery.com/jquery-3.2.1.slim.min.js"
      integrity="sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN"
      crossorigin="anonymous"
    ></script>

    <script src="aws-sdk.js"></script>
    <script src="tmi.js"></script>
    <script src="ssml_error.js"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/handlebars.js/2.0.0-alpha.1/handlebars.min.js"></script>
    <script src="https://code.jquery.com/jquery-1.10.1.min.js"></script>
    <script src="awsTranslateSupportedLanguages.js"></script>

    <script id="system-voice-template" type="text/x-handlebars-template">
      <dt>System Voice Selection: </dt>
      <dd class="clearfix">
        <select id="systemVoice" onchange="voiceSelected(this.value)">
          {{#select voice}}
            {{#each voices.Voices}}
              <option value="{{Id}}">{{Id}}
                ({{LanguageCode}}
                --
                {{LanguageName}})</option>
            {{/each}}
          {{/select}}
        </select>
        <input type="hidden" size="10" name="voice-option" id="voice-option" value="{{voice_option}}" />
      </dd>
      <div id="systemVoiceOptionPlaceholder"></div>
    </script>

    <script id="system-voice-option-template" type="text/x-handlebars-template">
      <select id="systemVoiceOption" onchange="voiceOptionSelected(this.value)">
        {{#select voiceOption}}
          {{#each voiceOptions}}
            <option value="{{this}}">{{this}}</option>
          {{/each}}
        {{/select}}
      </select>
    </script>

    <script id="lang-template" type="text/x-handlebars-template">
      <dt>{{name}}</dt>
      <dd class="clearfix">
        <select id="{{elementId}}" class="form-control" onchange="saveLocalStorageLang('{{elementId}}')">
          <option value="auto">Auto</option>
          {{#each langs}}
            <option value="{{this.languageCode}}">{{this.languageName}}
              ({{this.languageCode}})</option>
          {{/each}}
        </select>
      </dd>
    </script>

    <script>
      // GLOBALS YAY
      var streamerIsSpeaking = false;
      var streamerLastSpoke = 0;
      var chatters = {};
      var localChattersData = {};
      var lastMessages = [];
      var voices = {};
      var voicesDesc = {};
      var sortedLanguages = [];
      var ssmlTextType = "text";
      var bttvEmotes = [];
      var ffzEmotes = [];
      var twitch_id = 0;
      var access_token = "";
      var last_speaker = "system";
      var last_speaker_time = Date.now();
      var websocketCustom;
      var websocketProd;
      var cctPopup;
      var hostname = location.hostname;
      var autoconnect = "true";
      var messageID = 1;
      var currentSpeakingMessageID = 0;

      const DEFAULT_COLORS = [
        "#b52d2d",
        "#5e5ef2",
        "#5cb55c",
        "#21aabf",
        "#FF7F50",
        "#9ACD32",
        "#FF4500",
        "#2E8B57",
        "#DAA520",
        "#D2691E",
        "#5F9EA0",
        "#1E90FF",
        "#FF69B4",
        "#8A2BE2",
        "#00FF7F",
      ];

      const HashCode = (str) => str.split("").reduce((s, c) => (Math.imul(31, s) + c.charCodeAt(0)) | 0, 0);

      const GetColorForUsername = (userName) =>
        DEFAULT_COLORS[Math.abs(HashCode(userName)) % (DEFAULT_COLORS.length - 1)];

      const defaultOutput = [{ label: "Default", deviceId: "default" }];

      var hash = window.location.hash;
      history.pushState("", document.title, window.location.pathname + window.location.search);
      //window.location.hash = "";

      function getHashParams() {
        var hashParams = {};
        var e,
          r = /([^&;=]+)=?([^&;]*)/g,
          q = hash.substring(1);
        while ((e = r.exec(q))) {
          hashParams[e[1]] = decodeURIComponent(e[2]);
        }
        return hashParams;
      }

      function showAuthButton() {
        var redirectURL =
          "https://securitylive.com/tts/safetokenXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX.html";

        if (hostname.includes("localhost")) {
          redirectURL =
            "http://localhost:8080/tts.bot/webfront/safetokenXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX.html";
        } else if (hostname.includes("dev.tts.bot")) {
          redirectURL =
            "https://dev.tts.bot/safetokenXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX.html";
        } else if (hostname.includes("tts.bot")) {
          redirectURL =
            "https://tts.bot/safetokenXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX.html";
        }

        var twitchURL =
          '<a href="https://id.twitch.tv/oauth2/authorize?client_id=dan71ek0pct1u7b8ht5u4h55zlcxvq&redirect_uri=' +
          redirectURL +
          '&response_type=token&scope=chat:read+chat:edit+channel:moderate+whispers:read+whispers:edit+channel_editor+moderator:manage:banned_users" class="btn btn-primary" > Authorize On Twitch</a >';

        $("#login").html(twitchURL);
        $("#login").show();
        $("#ttsinfo").show();
        $("#loggedin").hide();
        $("#ttsinfo").show();
      }

      var params = getHashParams();
      const url = new URL(window.location.href);
      access_token = params.access_token;

      function toggleSettingsMenu() {
        var menu = document.getElementById("settingsMenu");
        var chatContainer = document.getElementById("chatContainer");
        if (menu.style.display === "none") {
          menu.style.display = "block";
          chatContainer.style.display = "none";
        } else {
          menu.style.display = "none";
          chatContainer.style.display = "block";
        }
      }

      if (url.searchParams.has("autoconnect")) {
        autoconnect = url.searchParams.get("autoconnect");
      }

      if (access_token) {
        localStorage.setItem("access_token", access_token);
      } else if (localStorage.getItem("access_token")) {
        access_token = localStorage.getItem("access_token");
      }

      $.ajax({
        url: "https://api.twitch.tv/helix/users",
        type: "GET",
        headers: {
          "client-id": "dan71ek0pct1u7b8ht5u4h55zlcxvq",
          Authorization: "Bearer " + access_token,
        },
        success: function (response) {
          var login = response.data[0].login;
          document.getElementById("twitch_username").value = login;
          var channel = login;

          if (localStorage.getItem("channel")) {
            channel = localStorage.getItem("channel");
          }

          document.getElementById("channel").value = channel;
        },
        error: function (response) {
          localStorage.removeItem("access_token");
          access_token = null;
          showAuthButton();
        },
      });

      function OpenPopup() {
        var popupURL = document.getElementById("txtCCTURL").value;
        if (hostname.includes("localhost")) {
          console.log("popup replace");
          popupURL = popupURL.replace(/securitylive\.com/g, "localhost/VeryNiceTTS");
        }
        cctPopup = window.open(popupURL, "Translator Window", "width=800,height=600");
      }

      if (localStorage.getItem("twitch_username")) {
        document.getElementById("twitch_username").value = localStorage.getItem("twitch_username");
      }

      if (localStorage.getItem("twitch_channel")) {
        document.getElementById("channel").value = localStorage.getItem("twitch_channel");
      }
      if (localStorage.getItem("chatters")) {
        chatters = JSON.parse(localStorage.getItem("chatters"));
        //console.log(chatters);
      }

      if (localStorage.getItem("websocketURL")) {
        document.getElementById("txtWebsocketURL").value = localStorage.getItem("websocketURL");
        document.getElementById("cbSendTextToWebsocket").checked = true;
      }
      if (localStorage.getItem("AWSwebsocketURL")) {
        document.getElementById("txtAWSWebsocketURL").value = localStorage.getItem("AWSwebsocketURL");
        document.getElementById("cbSendTextToAWSWebsocket").checked = true;
      }

      loadCheckboxes();
      loadTextFields();

      if (chatters == undefined) {
        chatters = {};
      }

      chatters["system"] = {};
      chatters["system"].voice = "justin";
      chatters["system"].voice_option = "neural";

      cred = {
        //
        // Generate your twitch OAuth Token at: https://twitchapps.com/tmi/ */
        //
        twitchUsername: "use input field",
        twitchOAuthToken: "use input field",

        //
        // This AWS token may go away at any time, register for a free AWS account and create an IAM role with
        // AmazonPollyReadOnlyAccess and TranslateReadOnly
        //
        awsAccessKeyId: "AKIAZOBVRH3RIEHEABV2",
        awsSecretAccessKey: "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",
      };

      AWS.config.region = "us-west-2";
      ep = new AWS.Endpoint("translate.us-west-2.amazonaws.com");

      AWS.config.credentials = new AWS.Credentials(cred.awsAccessKeyId, cred.awsSecretAccessKey);
      window.translator = new AWS.Translate({
        endpoint: ep,
        region: AWS.config.region,
      });

      async function loadFFZEmotes() {
        var request = new XMLHttpRequest();
        var set_id = 0;

        await $.ajax({
          url: "https://api.frankerfacez.com/v1/_room/" + document.getElementById("twitch_username").value,
          success: function (response) {
            //console.log("response:", response);
            twitch_id = response.room.twitch_id;
            set_id = response.room.set;
            console.log("set_id:", set_id);
            console.log("twitch_id:", twitch_id);
          },
          error: function (request, status, error) {
            console.log("loadFFZEmotes room error:", error);
          },
        });

        await $.ajax({
          url: "https://api.frankerfacez.com/v1/set/" + set_id,
          success: function (response) {
            for (const emote of response.set.emoticons) {
              ffzEmotes.push(emote.name);
            }
            for (const emote of ffzEmotes) {
            }
          },
          error: function (request, status, error) {
            console.log("loadFFZEmotes set error:", error);
          },
        });
      }

      // Hack job to get twitch_id from FFZ first, call this second, always.
      async function loadBTTVEmotes() {
        var request = new XMLHttpRequest();
        request.open("GET", "https://api.betterttv.net/3/cached/users/twitch/" + twitch_id, true);
        request.onreadystatechange = function () {
          if (request.readyState === 4 && request.status === 200) {
            var responseJSON = JSON.parse(request.responseText);
            for (const emote of responseJSON.channelEmotes) {
              bttvEmotes.push(emote.code);
            }
            for (const emote of responseJSON.sharedEmotes) {
              bttvEmotes.push(emote.code);
            }
          }
        };
        await request.send(null);
      }

      async function loadBTTVGlobalEmotes() {
        var request = new XMLHttpRequest();
        request.open("GET", "https://api.betterttv.net/3/cached/emotes/global", true);
        request.onreadystatechange = function () {
          if (request.readyState === 4 && request.status === 200) {
            var responseJSON = JSON.parse(request.responseText);
            for (const emote of responseJSON) {
              bttvEmotes.push(emote.code);
            }
          }
        };
        await request.send(null);
      }

      function saveCheckbox(event) {
        localStorage.setItem(event.target.id, document.getElementById(event.target.id).checked);
      }

      function loadCheckboxes() {
        var keys = Object.keys(localStorage),
          i = 0,
          key;

        for (; (key = keys[i]); i++) {
          if (key.startsWith("cb")) {
            document.getElementById(key).checked = JSON.parse(localStorage.getItem(key));
          }
        }
      }

      function saveTextField(event) {
        localStorage.setItem(event.target.id, document.getElementById(event.target.id).value);
      }

      function loadTextFields() {
        var keys = Object.keys(localStorage),
          i = 0,
          key;

        for (; (key = keys[i]); i++) {
          if (key.startsWith("txt")) {
            document.getElementById(key).value = localStorage.getItem(key);
          }
        }
      }

      /**************************Client Connecting****************************/
      function onConnecting(address, port) {
        document.getElementById("status").innerHTML = " [ Connecting...]";
      }

      function onConnected(address, port) {
        document.getElementById("status").innerHTML = " [ Connected ]";
        let message = "<speak>Connected to channel " + getSpokenName(con.channel) + ".</speak>";
        addSystemBubble(message, ++messageID);
        window.audioPlayer.Speak("", message, "", "system", "ssml", messageID);

        //window.audioPlayer.Speak("Connected to channel " + con.channel, "justin");

        localStorage.setItem("twitch_username", document.getElementById("twitch_username").value);
        localStorage.setItem("twitch_channel", document.getElementById("channel").value);
        localStorage.setItem("systemVoice", document.getElementById("systemVoice").value);
        localStorage.setItem("systemVoiceOption", document.getElementById("systemVoiceOption").value);

        if (localStorage.getItem("cbAutoTranslateChat")) {
          document.getElementById("cbAutoTranslateChat").checked = JSON.parse(
            localStorage.getItem("cbAutoTranslateChat")
          );
        } else if (
          document.getElementById("twitch_username").value ||
          document.getElementById("twitch_channel").value
        ) {
          document.getElementById("cbAutoTranslateChat").checked = true;
        }
      }
      /**************************Client Connecting****************************/
      function onBan(channel, username, reason) {
        console.log("arguments:", arguments, "reason:", reason);
        //ttsBanByUser(channel.substring(1), username);
        window.audioPlayer.SpeakNow(
          "<speak>Hey chat, " + username + " was banned, thought you should know.</speak>",
          "system",
          "ssml"
        );
      }

      function onCheer() {
        console.log("onCheer:", arguments);
      }
      function onSub() {
        console.log("onSub:", arguments);
      }
      function onRitual() {
        console.log("onRitual:", arguments);
      }
      function onRaid() {
        console.log("onRaid:", arguments);
      }

      /**************************Init and Connect to Chat****************************/
      async function connect() {
        init();

        //Twitch Client
        var options = {
          options: {
            debug: false,
            skipUpdatingEmotesets: true,
          },
          connection: {
            cluster: "aws",
            reconnect: true,
          },
          identity: {
            username: document.getElementById("twitch_username").value,
            password: access_token,
          },
          channels: [con.channel],
        };

        window.client = tmi.client(options);

        window.client.connect();

        localStorage.setItem("channel", con.channel);

        //Attached Handlers
        window.client.on("chat", onChat);
        window.client.on("connecting", onConnecting);
        window.client.on("connected", onConnected);
        window.client.on("ban", onBan);
        window.client.on("cheer", onCheer);
        window.client.on("subscription", onSub);
        window.client.on("resub", onSub);
        window.client.on("ritual", onRitual);
        window.client.on("raided", onRaid);

        //Disable UI Elements
        document.getElementById("srcLangSelect").disabled = true;
        document.getElementById("dstLangSelect").disabled = true;
        document.getElementById("channel").disabled = true;
        document.getElementById("btn-go").disabled = true;

        await loadFFZEmotes();
        // Hack job to get twitch_id from FFZ first, call this second, always.
        await loadBTTVEmotes();
        await loadBTTVGlobalEmotes();

        if (document.getElementById("cbSendTextToWebsocket").checked) {
          websocketCustomConnect();
        }
        if (document.getElementById("cbSendTextToAWSWebsocket").checked) {
          websocketAWSConnect();
        }
      }

      function enableCustomWebsocket(checked) {
        if (checked) {
          websocketCustomConnect();
        } else {
          websocketCustom.close();
        }
      }

      function enableAWSWebsocket(checked) {
        if (checked) {
          websocketAWSConnect();
        } else {
          websocketProd.close();
        }
      }

      function websocketCustomConnect() {
        console.log("setting up websocket", document.getElementById("cbSendTextToWebsocket").value);
        var websocketURL = document.getElementById("txtWebsocketURL").value;

        try {
          websocketCustom = new WebSocket(websocketURL);
        } catch (err) {
          console.log("cannot connect to websocketCustom: catch(" + err + ")");
        }

        websocketCustom.onopen = function () {
          console.log("Connected to websocket backend.");
          localStorage.setItem("websocketURL", websocketURL);
        };

        websocketCustom.onmessage = function (event) {
          console.log("websocketCustom.message:", event);

          let command = JSON.parse(event.data);

          if (command.topic == "TTS") {
            console.log(command);
            window.audioPlayer.SpeakNow(command.text, command.username, "text", command.voice);
          } else {
            window.audioPlayer.SpeakNow("<speak>" + event.data + "</speak>", "system", "ssml");
          }
        };

        websocketCustom.onclose = function (e) {
          console.log("Socket is closed. Reconnect will be attempted in 1 second.", e.reason);
          setTimeout(function () {
            websocketCustomConnect();
          }, 1000);
          //setInterval(websocketConnectRetry, 5000);
        };

        websocketCustom.onerror = function (err) {
          console.log("Websocket connect error to:", websocketURL, err);
          websocketCustom.close();
          //document.getElementById('cbSendTextToWebsocket').checked = false;
        };
      }

      function websocketAWSConnect() {
        console.log("setting up AWS websocket", document.getElementById("cbSendTextToAWSWebsocket").value);
        var AWSWebsocketURL = document.getElementById("txtAWSWebsocketURL").value;

        websocketProd = new WebSocket(AWSWebsocketURL + "/?channel=" + con.channel);

        websocketProd.onopen = function () {
          console.log("Connected to AWS websocket backend.");
          localStorage.setItem("AWSWebsocketURL", AWSWebsocketURL);
          var wsObject = {
            action: "start",
            channel: con.channel,
            access_token: access_token,
            time: Date.now(),
          };
          websocketProd.send(JSON.stringify(wsObject));
        };

        websocketProd.onmessage = function (event) {};

        websocketProd.onclose = function (e) {
          console.log("AWS Socket is closed. Reconnect will be attempted in 1 second.", e.reason);
          setTimeout(function () {
            websocketAWSConnect();
          }, 1000);
          //setInterval(websocketConnectRetry, 5000);
        };

        websocketProd.onerror = function (err) {
          console.log("AWS Websocket connect error to:", AWSWebsocketURL, err);
          websocketProd.close();
          //document.getElementById('cbSendTextToWebsocket').checked = false;
        };
      }

      function init() {
        //Get UI Controls
        var lc = document.getElementById("livechat");
        var lcc = document.getElementById("livechatc");
        var cbspeak = document.getElementById("cbSpeak");
        var cbsend = document.getElementById("cbAutoTranslateChat");
        var sendMessage = document.getElementById("message");

        //Cache values
        con = {
          channel: document.getElementById("channel").value,
          sourceLanguage: document.getElementById("srcLangSelect").value,
          targetLanguage: document.getElementById("dstLangSelect").value,
          liveChatUI: lc,
          liveChatUIContainer: lcc,
          cbSpeak: cbspeak,
          cbAutoTranslateChat: cbsend,
          sendMessage: sendMessage,
        };

        lc.innerHTML = "";

        window.audioPlayer = AudioPlayer();
      }

      function loadAndSortLanguages() {
        for (const key in supportedLanguages.en) {
          var lang = supportedLanguages.en[key];
          var tmp = {};
          tmp.languageCode = key;
          tmp.languageName = lang;
          sortedLanguages.push(tmp);
        }
        sortedLanguages.sort(function (a, b) {
          return a.languageName > b.languageName ? 1 : -1;
        });
      }

      function voiceSelected(voice) {
        var userVoiceOptionSource = document.getElementById("system-voice-option-template").innerHTML,
          userVoiceOptionTemplate = Handlebars.compile(userVoiceOptionSource),
          userVoiceOptionPlaceholder = document.getElementById("systemVoiceOptionPlaceholder");
        userVoiceOptionPlaceholder.innerHTML = userVoiceOptionTemplate(voices[voice.toLowerCase()]);
        var voiceOption = document.getElementById("voice-option");
        voiceOption.value = voices[voice.toLowerCase()].voiceOptions[0];

        localStorage.setItem("systemVoice", document.getElementById("systemVoice").value);
        localStorage.setItem("systemVoiceOption", document.getElementById("systemVoiceOption").value);
      }

      function voiceOptionSelected(voiceOption) {
        var voiceOptionElement = document.getElementById("voice-option");
        voiceOptionElement.value = voiceOption;

        localStorage.setItem("systemVoice", document.getElementById("systemVoice").value);
        localStorage.setItem("systemVoiceOption", document.getElementById("systemVoiceOption").value);
      }

      function saveLocalStorageLang(elementId) {
        console.log("elementId:", elementId);
        localStorage.setItem(elementId, document.getElementById(elementId).value);
      }

      /**************************Init and Connect to Chat****************************/

      function getHTMLEntityEncoding(char) {
        switch (char) {
          case "<":
            return "&lt;";
          case ">":
            return "&gt;";
          case "'":
            return "&apos;";
          case '"':
            return "&quote;";
          case "&":
            return "&amp;";
          case ";":
            return "&semi;";
        }
      }

      function escapeRegExp(text) {
        return text.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
      }

      /**************************Receive and Translate Chat****************************/
      async function onChat(channel, userstate, message, self) {
        let speakEmotes = document.getElementById("cbSpeakEmotesTTS").checked;
        let dedupEmotes = document.getElementById("cbDedupEmotesTTS").checked;
        let matchedEmotes = [];
        // Don't listen to my own messages..
        channel = channel.replace("#", "");
        message = message.trim();

        //console.log(userstate);
        //console.log("message", message);
        //console.log("chatters:", chatters);

        if (userstate["custom-reward-id"] == "9914796b-d33c-4317-bb9e-e66b5d372ac2") {
          client
            .deletemessage(channel, userstate.id)
            .then((data) => {
              console.log("Injection deleted", userstate);
            })
            .catch((err) => {
              console.log("Failed to delete injection", userstate);
            });
          return;
        }
        // TODO delete messages with injection stuffs
        // || message.match('(?!<\w+>.*</\w+>)')

        if (self) return;

        //console.log("userstate:", userstate);
        var username = userstate["username"];

        // TODO speak text up to comment delimiter
        if (message.match("(^\s*-|^\s*#|^\s*<!--|^\s*;|^\s*//)")) {
          //last_speaker = username;
          return;
        }

        if (message.match(/^(oneword|one word|!oneword)/i)) {
          return;
        }

        let allowTTS = false;
        let allowTTSmessage = "";

        if (document.getElementById("cbEveryoneTTS").checked) {
          //console.log("cbEveryone");
          allowTTS = true;
        } else if (document.getElementById("cbModTTS").checked && userstate.mod) {
          //console.log("cbMod");
          allowTTS = true;
        } else if (document.getElementById("cbVipTTS").checked && userstate.badges.hasOwnProperty("vip")) {
          //console.log("cbVip");
          allowTTS = true;
        } else if (document.getElementById("cbSubTTS").checked && userstate.subscriber) {
          //console.log("cbSub");
          allowTTS = true;
        }

        if (!speakEmotes && userstate["emote-only"]) {
          allowTTS = false;
          allowTTSmessage += "Emote Only Chat - ";
        } else if (!speakEmotes || (speakEmotes && dedupEmotes)) {
          var emoteParsingStart = window.performance.now();

          var twitchEmotes = [];
          for (const key in userstate.emotes) {
            var strPos = userstate.emotes[key][0].split("-");
            twitchEmotes.push(message.substring(parseInt(strPos[0]), parseInt(strPos[1]) + 1));
          }
          for (let emote of twitchEmotes) {
            emote = escapeRegExp(emote);
            matchedEmotes.push(message.match(emote));
            message = message.replaceAll(emote, "");
          }
          for (const emote of bttvEmotes) {
            //console.log("bttv emote:", emote);
            matchedEmotes.push(message.match(emote));
            message = message.replaceAll(emote, "");
          }
          for (const emote of ffzEmotes) {
            matchedEmotes.push(message.match(emote));
            message = message.replaceAll(emote, "");
          }

          //console.log("matched emotes:", matchedEmotes);

          //console.log("Base message is now:", message);

          matchedEmotes = matchedEmotes.filter(function (element) {
            return element != null;
          });

          if (speakEmotes && dedupEmotes) {
            for (const emote of matchedEmotes) {
              message += " " + emote[0];
            }
          }
          //console.log("found emotes:", matchedEmotes[0][0]);

          var time_diff = window.performance.now() - emoteParsingStart;
          /*console.log(
                                  "processed emotes in:",
                                  parseFloat(time_diff).toFixed(2),
                                  "ms"
                                );*/
        }

        if (username == "streamelements" || username == "pretzelrocks" || username.includes("welcome to my channel")) {
          last_speaker = username;
          return;
        }

        ssmlTextType = "text";
        if (message.match("^<speak>.*</speak>$")) {
          ssmlTextType = "ssml";
        } else if (message.match("<speak>.*</speak>")) {
        }

        if (!chatters.hasOwnProperty(username)) {
          chatters[username] = {};
          chatters[username].voice = "justin";
          chatters[username].voice_option = "standard";
          chatters[username].spoken_name = username;
          chatters[username].ttsBanned = false;
          chatters[username].display_name = userstate["display-name"];
          chatters[username].color = userstate.color;
          localStorage.setItem("chatters", JSON.stringify(chatters));
        }

        await loadVoice(userstate);
        localStorage.setItem("chatters", JSON.stringify(chatters));

        if (chatters[username].hasOwnProperty("ttsBanned") && chatters[username].ttsBanned) {
          allowTTS = false;
          allowTTSmessage += "TTS Banned - ";
        }

        if (message) {
          if (message.match("(^\s*!)")) {
            //last_speaker = username;
            runChatCommand(channel, username, message, userstate.mod);

            if (document.getElementById("cbDeleteCommands").checked)
              client
                .deletemessage(channel, userstate.id)
                .then((data) => {
                  console.log("Message deleted", userstate);
                })
                .catch((err) => {
                  console.log("Failed to delete message", userstate);
                });
            return;
          }

          var params = {
            //Settings: {
            //  Profanity: "MASK"
            //},
            Text: message,
            SourceLanguageCode: con.sourceLanguage,
            TargetLanguageCode: con.targetLanguage,
          };

          window.translator.translateText(params, function onIncomingMessageTranslate(err, data) {
            //console.log('Original Message  : ' + message);
            //console.log('Translated Message: ' + data.TranslatedText);

            var translatedMessage = data.TranslatedText;
            var identicalTranslation = false;
            if (message.trim() === translatedMessage.trim()) {
              identicalTranslation = true;
            }

            if (err) {
              console.log("Error calling Translate. " + err.message + err.stack);
            }
            if (data) {
              let spokenText = translatedMessage;
              spokenText = spokenText.replace(/&/g, function (i) {
                return "and";
              });
              translatedMessage = translatedMessage.replace(/[<>;&'"]/g, function (i) {
                var entity = getHTMLEntityEncoding(i);
                return entity;
              });
              message = message.replace(/[<>;&'"]/g, function (i) {
                var entity = getHTMLEntityEncoding(i);
                return entity;
              });

              var targetLang = document.getElementById("dstLangSelect").value;
              var translatedFromMessage = "";

              if (document.getElementById("dstLangSelect").value != data.SourceLanguageCode) {
                if (message.startsWith("~")) {
                  spokenText = message.substring(1);
                } else {
                  translatedFromMessage = "Translated from " + supportedLanguages.en[data.SourceLanguageCode];
                }

                if (con.cbAutoTranslateChat.checked && !identicalTranslation) {
                  window.client.action(
                    con.channel,
                    chatters[username].display_name +
                      ": " +
                      translatedMessage +
                      " (Translated from " +
                      supportedLanguages.en[data.SourceLanguageCode] +
                      ")"
                  );
                }
              }

              let similarity = 0;
              let minSimilarity = 75;
              let maxTimeAgoMS = 300000;
              let now = Date.now();

              if (document.getElementById("cbUserLevDistance").checked) {
                minSimilarity = parseInt(document.getElementById("txtUserLevPct").value);
                maxTimeAgoMS = parseInt(document.getElementById("txtUserLevTime").value) * 1000;
                if (localChattersData[username] && localChattersData[username].hasOwnProperty("lastMessages")) {
                  for (const message of localChattersData[username].lastMessages) {
                    similarity = similarityPercentage(spokenText, message.message);

                    if (similarity > minSimilarity && now - message.timestamp < maxTimeAgoMS) {
                      allowTTS = false;
                      allowTTSmessage += "User Lev Distance - ";
                      break;
                    }
                  }

                  const startIndex = Math.max(0, localChattersData[username].lastMessages.length - 20);
                  localChattersData[username].lastMessages = localChattersData[username].lastMessages.slice(startIndex);
                }
              }

              now = Date.now();

              if (document.getElementById("cbChatLevDistance").checked) {
                maxTimeAgoMS = parseInt(document.getElementById("txtChatLevTime").value) * 1000;
                minSimilarity = parseInt(document.getElementById("txtChatLevPct").value);
                for (const message of lastMessages) {
                  similarity = similarityPercentage(spokenText, message.message);

                  if (similarity > minSimilarity && now - message.timestamp < maxTimeAgoMS) {
                    allowTTS = false;
                    allowTTSmessage += "Chat Lev Distance - ";
                    break;
                  }
                }

                const startIndex = Math.max(0, lastMessages.length - 20);
                lastMessages = lastMessages.slice(startIndex);
              }

              let color = "#FFFFFF";
              if (chatters[username].color) {
                color = chatters[username].color;
              } else {
                color = GetColorForUsername(username);
              }

              let translatedMessageHTML = "";
              if (document.getElementById("dstLangSelect").value != data.SourceLanguageCode) {
                translatedMessageHTML = `${translatedMessage} (${translatedFromMessage})`;
              }

              if (identicalTranslation) translatedMessageHTML = "";

              let announceVoice = "System Voice";
              let userVoice = `${chatters[username].voice} (${chatters[username].voice_option})`;

              let speakerIcon = "";
              if (!allowTTS) {
                userVoice = `(${allowTTSmessage.slice(0, -3)})`;
                speakerIcon = "";
              }

              messageID++;

              //  let buttons = makeButton("Don't Speak", "secondary", "comment-slash", username, messageID) +
              //makeButton("Speak Next", "success", "comment-medical", username, messageID) +
              let buttons =
                makeButton("TTS Ban", "warning", "volume-xmark", username, messageID) +
                makeButton("Ban", "danger", "gavel", username, messageID);

              con.liveChatUI.innerHTML += `<div id="message-id${messageID}" class="chat-bubble">
                              <div class="username-container" id="message-user-id${messageID}">
                                <div class="speaker-info">
                <span class="speaker-icon">${speakerIcon}</span>
                <span id="message-system-voice-id${messageID}" class="voice-name">SYSTEM VOICE</span>
              </div>
                                <span class="username">
                                <strong style='color:${color}'>
                            ${chatters[username].display_name}:</strong><br>(${chatters[username].spoken_name.trim()})


                            </span></div>

                            <div class="message-container" id="message-message-id${messageID}">
                              <div class="speaker-info">
                <span class="speaker-icon">${speakerIcon}</span>
                <span class="voice-name">${userVoice}</span>
              </div>
                              <span class="message">

                              ${message}<br>

                              ${translatedMessageHTML}

                              </span></div>

                            <div class="buttons-container" ><span class="btn-group">
                            ${buttons}
                    </span></div></div>`;

              //If speak translation in enabled, speak translated message
              if (con.cbSpeak.checked && allowTTS) {
                var regex = /_/gi;
                var longnumex = /\d{6,}/;
                var linkex = /(?:(?:https?):\/\/)?(?:[\w-]+(?:\.[\w-]+)+)(?:\/[^\s]*)?/g;
                //var longex = /\S{100,}/g;

                spokenText = spokenText.replace(regex, " ");
                spokenText = spokenText.replace(linkex, " (Web link) ");
                spokenText = spokenText.replace(longnumex, " (Long number) ");
                //spokenText = spokenText.replace(longex, ' (long word) ');

                var prefix = "";
                if (last_speaker != username) {
                  prefix = "<speak>" + getSpokenName(username) + " says </speak>";
                }
                audioPlayer.Speak(prefix, spokenText, translatedFromMessage, username, ssmlTextType, messageID);

                if (!localChattersData[username]) {
                  localChattersData[username] = {};
                  localChattersData[username].lastMessages = [];
                  console.log(`A new chatter has entered the ring: ${username} --  ${spokenText} -- ${similarity}`);
                }

                let tmpMessage = {
                  message: spokenText,
                  timestamp: Date.now(),
                };

                localChattersData[username].lastMessages.push(tmpMessage);
                lastMessages.push(tmpMessage);

                last_speaker = username;
              } else {
                console.log("DENIED TTS:", userstate);
              }

              con.liveChatUIContainer.scrollTop = con.liveChatUIContainer.scrollHeight;
            }
          });
        }
      }

      function addSystemBubble(message, messageID) {
        con.liveChatUI.innerHTML += `<div id="message-id${messageID}" class="chat-bubble">
  <div class="username-container" id="message-user-id${messageID}">
    <div class="speaker-info">
      <span class="speaker-icon"></span>
      <span id="message-system-voice-id${messageID}" class="voice-name">SYSTEM VOICE</span>
    </div>
    <span class="username">
      <strong style="color:${GetColorForUsername("System")}">System</strong>
     </span>
  </div>

  <div class="message-container" id="message-message-id${messageID}">
    <span class="message">
      ${message}
    </span>
  </div>
  <div class="buttons-container"><span class="btn-group"></span></div>
</div>
`;
      }

      function makeButton(btnName, btnClass, btnIcon, btnArgument, mID) {
        var messageButtonName = btnName.replace(/\W/g, "");

        if (messageButtonName == "TTSBan" && chatters[btnArgument].ttsBanned) {
          btnName = "TTS Unban";
          messageButtonName = "TTSUnban";
        } else if (messageButtonName == "DontSpeak") {
          btnArgument = mID;
        }

        return `<button id="messageButton-${messageButtonName}-id${mID}" class="btn btn-${btnClass}" title="${messageButtonName}" onclick='onButtonClick("${messageButtonName}", "${btnArgument}", event)'>
              <div>
                <i class="fa-solid fa-${btnIcon}"></i>
              </div>
              <div>
                <span class="small">${btnName}</span>
              </div>
            </button>`;
      }

      function onButtonClick(button, argument, event) {
        console.log(`onButtonClick(${button}, ${argument}, ${event})`);

        if (button == "Ban") {
          ttsBanByUser(con.channel, argument);
        } else if (button == "TTSBan") {
          ttsBan(con.channel, "!ttsban " + argument, true);
        } else if (button == "TTSUnban") {
          ttsBan(con.channel, "!ttsban " + argument, false);
        } else if (button == "SpeakNext") {
          ttsBan(con.channel, "!ttsban " + argument, true);
        } else if (button == "DontSpeak") {
          skipMessage(arguement);
          //event.target.disabled = true;
        }
      }

      function levenshteinDistance(s1, s2) {
        s1 = s1.toLowerCase().trim();
        s2 = s2.toLowerCase().trim();
        if (s1.length > s2.length) {
          [s1, s2] = [s2, s1];
        }

        let distances = Array.from({ length: s1.length + 1 }, (_, i) => i);

        for (let i2 = 0; i2 < s2.length; i2++) {
          const c2 = s2[i2];
          let distances_ = [i2 + 1];
          for (let i1 = 0; i1 < s1.length; i1++) {
            const c1 = s1[i1];
            if (c1 === c2) {
              distances_.push(distances[i1]);
            } else {
              distances_.push(1 + Math.min(distances[i1], distances[i1 + 1], distances_[distances_.length - 1]));
            }
          }
          distances = distances_;
        }

        return distances[distances.length - 1];
      }

      function similarityPercentage(s1, s2) {
        const levenshteinDist = levenshteinDistance(s1, s2);
        const longestLength = Math.max(s1.length, s2.length);
        return (1 - levenshteinDist / longestLength) * 100;
      }

      function runChatCommand(channel, username, message, mod) {
        if (!chatters.hasOwnProperty(username)) {
          chatters[username] = {};
        }

        console.log("channel:" + channel + ":" + username + ":");

        if (message.startsWith("!setvoice")) {
          parts = message.split(" ");
          var voice = "justin";
          var voice_option = "standard";

          if (parts.length < 2) {
            return;
          }

          voice = parts[1];

          if (parts.length > 2) {
            voice_option = parts[2];
          }

          // Check if parameter is a 1 or more digit number
          if (/^(\d+)$/.test(voice)) {
            var i = parseInt(voice);
            voice = voicesDesc.Voices[i].Id;
          }

          voice = voice.toLowerCase();
          if (!voices.hasOwnProperty(voice)) {
            voice = "justin";
          }

          if (!voices[voice].voiceOptions.includes(voice_option)) {
            voice_option = voices[voice].voiceOptions[0];
          }

          chatters[username].voice = voice;

          if (voice_option == "neural" || voice_option == "standard") {
            chatters[username].voice_option = voice_option;
          }
          saveTTSConfig(channel, username);
        } else if (message.startsWith("!setspoken") || message.startsWith("!setname")) {
          message = message.replace("!setspoken", "");
          message = message.replace("!setname", "");
          message = message.trim();
          if (message == "") {
            chatters[username].spoken_name = username;
          } else {
            chatters[username].spoken_name = message;
          }
          saveTTSConfig(channel, username);
        } else if (message.startsWith("!voices")) {
          sendVoiceListToChat();
        } else if (message.startsWith("!poof") || message.startsWith("!poop") || message.startsWith("!pop")) {
          window.audioPlayer.PopLastMessage(username);
        } else if (message.startsWith("!ttsdump") || message.startsWith("!dump")) {
          parts = message.split(" ");
          if (parts.length < 2 && (mod || channel == username)) {
            window.audioPlayer.Dump();
          } else if (parts.length > 1 && (mod || channel == username)) {
            var user = parts[1];
            window.audioPlayer.DumpByUser(user);
          } else {
            window.audioPlayer.DumpByUser(username);
          }
        } else if (message.startsWith("!ttsban") && (mod || channel == username)) {
          ttsBan(channel, message, true);
        } else if (message.startsWith("!ttsunban") && (mod || channel == username)) {
          ttsBan(channel, message, false);
        }
      }

      function ttsBan(channel, message, ban) {
        parts = message.split(" ");
        if (parts.length > 1) {
          var user = parts[1].toLowerCase();
          user = user.replace("@", "");
          if (ban) {
            window.audioPlayer.DumpByUser(user);
          }
          chatters[user].ttsBanned = ban;
          saveTTSConfig(channel, user);
        }
      }

      function ttsBanByUser(channel, user) {
        chatters[user].ttsBanned = true;
        window.audioPlayer.DumpByUser(user);
        saveTTSConfig(channel, user);
        banUser(twitch_id, user);

        /*client.ban(channel, user).then(function () {
                                      console.log("Successfully banned " + user.username + " on " + channel + "!");
                                    }, function (err) {
                                      console.log(err);
                                    });*/
      }

      function ttsUnbanByUser(channel, user) {
        chatters[user].ttsBanned = false;
        //window.audioPlayer.DumpByUser(user);
        saveTTSConfig(channel, user);
        unbanUser(twitch_id, user);
        /*
                                    client.unban(channel, user).then(function () {
                                      console.log("Successfully unbanned " + user.username + " on " + channel + "!");
                                    }, function (err) {
                                      console.log(err);
                                    });
                                    */
      }

      async function banUser(channel_id, login, reason) {
        if (!reason) {
          reason = "no reason specified";
        }

        console.log("channel_id:", twitch_id, "login:", login);
        let login_id_to_ban = null;

        await $.ajax({
          url: "https://api.twitch.tv/helix/users?login=" + login,
          type: "GET",
          headers: {
            "client-id": "dan71ek0pct1u7b8ht5u4h55zlcxvq",
            Authorization: "Bearer " + access_token,
          },
          success: function (response) {
            console.log(response);
            login_id_to_ban = response.data[0].id;
            console.log("banUser() got login_id:", login_id_to_ban);
          },
          error: function (response) {
            console.log("unable to lookup", login, "for ban");
          },
        });

        if (login_id_to_ban) {
          console.log(
            "url:",
            `https://api.twitch.tv/helix/moderation/bans?broadcaster_id=${channel_id}&moderator_id=${channel_id}`
          );
          await $.ajax({
            url: `https://api.twitch.tv/helix/moderation/bans?broadcaster_id=${channel_id}&moderator_id=${channel_id}`,
            type: "POST",
            dataType: "json",
            contentType: "application/json",
            headers: {
              "Client-ID": "dan71ek0pct1u7b8ht5u4h55zlcxvq",
              Authorization: `Bearer ${access_token}`,
            },
            data: JSON.stringify({
              data: {
                user_id: login_id_to_ban,
                reason: reason,
                // Optionally, you can add a duration and a reason:
                // duration: TIMEOUT_DURATION_IN_SECONDS,
                // reason: "REASON_FOR_BAN_OR_TIMEOUT"
              },
            }),
            success: function (response) {
              console.log("User banned successfully:", response);
            },
            error: function (error) {
              console.error("Error banning user:", error);
            },
          });
        }
      }

      async function unbanUser(channel_id, login) {
        console.log("channel_id:", twitch_id, "login:", login);
        let login_id_to_unban = null;

        await $.ajax({
          url: "https://api.twitch.tv/helix/users?login=" + login,
          type: "GET",
          headers: {
            "client-id": "dan71ek0pct1u7b8ht5u4h55zlcxvq",
            Authorization: "Bearer " + access_token,
          },
          success: function (response) {
            console.log(response);
            login_id_to_unban = response.data[0].id;
            console.log("unbanUser() got login_id:", login_id_to_unban);
          },
          error: function (response) {
            console.log("unable to lookup", login, "for ban");
          },
        });

        if (login_id_to_unban) {
          console.log(
            "url:",
            `https://api.twitch.tv/helix/moderation/bans?broadcaster_id=${channel_id}&moderator_id=${channel_id}&user_id=${login_id_to_unban}`
          );
          await $.ajax({
            url: `https://api.twitch.tv/helix/moderation/bans?broadcaster_id=${channel_id}&moderator_id=${channel_id}&user_id=${login_id_to_unban}`,
            type: "DELETE",
            dataType: "json",
            contentType: "application/json",
            headers: {
              "Client-ID": "dan71ek0pct1u7b8ht5u4h55zlcxvq",
              Authorization: `Bearer ${access_token}`,
            },
            success: function (response) {
              console.log("User banned successfully:", response);
            },
            error: function (error) {
              console.error("Error banning user:", error);
            },
          });
        }
      }

      async function saveTTSConfig(channel, username) {
        //('saveTTSConfig(' + channel + ',' + username + ')');
        var data = {};
        var request = {};
        data.login = username;
        data.voice = chatters[username].voice;
        data.voice_option = chatters[username].voice_option;
        data.spoken_name = chatters[username].spoken_name;
        data.ttsBanned = chatters[username].ttsBanned;
        data.access_token = access_token;
        request.data = [];
        request.data.push(data);
        //console.log("saveTTSConfig request data:", request);
        var url = "https://api.securitylive.com/tts/" + channel + "/" + username;
        await $.ajax({
          url: url,
          type: "PUT",
          dataType: "json",
          contentType: "application/json",
          data: JSON.stringify(request),
          success: function (response) {
            console.log("Config Saved Successfully:", response);

            //alert("Save Much Success!");
          },
          error: function (error) {
            console.log("Config Save Failed:", error);
            return;
          },
        });
        localStorage.setItem("chatters", JSON.stringify(chatters));
        //console.log("localStorage:", localStorage.getItem('chatters'));
      }

      async function buildVoiceLookup() {
        return new Promise(function (resolve, reject) {
          //console.log('buildVoiceLookup()');

          var polly = new AWS.Polly();
          //console.log('pulling voices from AWS API');
          var params = {};

          polly.describeVoices(params, async function (err, data) {
            if (err) {
              console.log(err, err.stack); // an error occurred
              reject(err);
            } else {
              voicesDesc = data;
              for (var i = 0; i < voicesDesc.Voices.length; i++) {
                var lcvoice = voicesDesc.Voices[i].Id.toLowerCase();
                var idvoice = voicesDesc.Voices[i].Id;
                voices[lcvoice] = {};
                voices[lcvoice].engine = voicesDesc.Voices[i].SupportedEngines[0];
                voices[lcvoice].voiceOptions = voicesDesc.Voices[i].SupportedEngines;
                voices[lcvoice].name = idvoice;
              }
              voicesDesc.Voices.sort(function (a, b) {
                if (a.LanguageCode === b.LanguageCode) {
                  return b.Id - a.Id;
                }
                return a.LanguageCode > b.LanguageCode ? 1 : -1;
              });
              resolve();
            }
          });
          //console.log(voices);
        });
      }

      function sendVoiceListToChat() {
        /*
                                    var neuralVoices = '';
                                    var standardVoices = '';
                                    for (var i = 0; i < voicesDesc.Voices.length; i++) {
                                      var voice = voicesDesc.Voices[i];
                                      if (voice.SupportedEngines[0] == 'standard') {
                                        standardVoices += i + ': ' + voice.Id + ' (' + voice.LanguageName + '), ';
                                      } else if (voice.SupportedEngines[0] == 'neural') {
                                        neuralVoices += i + ': ' + voice.Id + ' (' + voice.LanguageName + '), ';
                                      }
                                    }
                                    window.client.action(con.channel, 'Neural Voices: ' + neuralVoices);
                                    window.client.action(con.channel, 'Standard Voices: ' + standardVoices);
                                    */
        window.client.action(con.channel, "Configure your voice here: https://securitylive.com/tts-config.html");
      }

      async function loadVoice(lvuserstate) {
        let username = lvuserstate.username;
        //console.log('loadVoice(' + username + ')');
        var channel = document.getElementById("channel").value;
        var hasLocalChannelConfig = false;
        await $.ajax({
          url: "https://api.securitylive.com/tts/" + channel + "/" + username,
          success: function (response) {
            //console.log("Data for " + channel + ":", response);
            if (response.hasOwnProperty("Item")) {
              //console.log('loadVoice(' + channel + '): ' + response.Item.voice.toLowerCase() + ' from DynamoDB');
              chatters[username] = {};
              chatters[username].voice = response.Item.voice.toLowerCase();
              chatters[username].voice_option = response.Item.voice_option;
              chatters[username].spoken_name = response.Item.spoken_name;
              chatters[username].ttsBanned = response.Item.ttsBanned;
              chatters[username].display_name = response.Item.display_name;
              chatters[username].color = lvuserstate.color;
              hasLocalChannelConfig = true;
            }
          },
          error: function (request, status, error) {
            console.log("loadVoice(" + channel + ") error: using Brian");
            chatters[username].voice = "brian";
            chatters[username].voice_option = "standard";
            chatters[username].display_name = lvuserstate["display-name"];
            chatters[username].color = lvuserstate.color;
          },
        });

        if (!hasLocalChannelConfig) {
          //console.log("Does not have local config.");
          await $.ajax({
            url: "https://api.securitylive.com/tts/all/" + username,
            success: function (response) {
              //console.log("Data from all for:", response);
              if (response.hasOwnProperty("Item")) {
                //console.log('loadVoice(global): ' + response.Item.voice.toLowerCase() + ' from DynamoDB');
                chatters[username] = {};
                chatters[username].voice = response.Item.voice.toLowerCase();
                chatters[username].voice_option = response.Item.voice_option;
                chatters[username].spoken_name = response.Item.spoken_name;
                chatters[username].ttsBanned = response.Item.ttsBanned;
                chatters[username].display_name = response.Item.display_name;
                chatters[username].color = lvuserstate.color;
              } else if (chatters[username].hasOwnProperty("voice")) {
                //console.log('loadVoice() chatters[' + username + '].voice: ' + chatters[username].voice);
                chatters[username].voice = "justin";
                chatters[username].voice_option = "standard";
                chatters[username].spoken_name = username;
                chatters[username].ttsBanned = false;
                chatters[username].display_name = lvuserstate["display-name"];
              } else {
                //console.log('loadVoice() catchall: using Justin for ' + username);
                chatters[username].voice = "justin";
                chatters[username].voice_option = "standard";
                chatters[username].spoken_name = username;
                chatters[username].ttsBanned = false;
                chatters[username].display_name = lvuserstate["display-name"];
                chatters[username].color = lvuserstate.color;
              }
            },
            error: function (request, status, error) {
              console.log("loadVoice(global) error: using Brian");
              chatters[username].voice = "brian";
              chatters[username].voice_option = "standard";
              chatters[username].ttsBanned = false;
              chatters[username].display_name = lvuserstate["display-name"];
              chatters[username].color = lvuserstate.color;
            },
          });
        }
      }

      function getSpokenName(username) {
        if (chatters[username] == undefined) {
          return username;
        } else if (chatters[username].spoken_name == undefined) {
          return username;
        } else {
          return chatters[username].spoken_name;
        }
      }

      /**************************Send Message****************************/

      function message_key(ele) {
        if (event.key === "Enter") {
          sendMessage();
        }
      }

      function sendMessage() {
        if (con.sendMessage.value) {
          message = con.sendMessage.value;
          var params = {
            Text: con.sendMessage.value,
            SourceLanguageCode: con.targetLanguage,
            TargetLanguageCode: document.getElementById("chatLangSelect").value,
          };

          window.translator.translateText(params, function onSendMessageTranslate(err, data) {
            if (err) {
              console.log("Error calling Translate. " + err.message + err.stack);
            }
            if (data) {
              //console.log("M: " + message);
              //console.log("T: " + translatedMessage);
              var translatedMessage = data.TranslatedText;

              //Send message to chat
              window.client.action(con.channel, translatedMessage);

              //Clear send message UI
              con.sendMessage.value = "";

              //Print original message in Translated UI
              con.liveChatUI.innerHTML += "<strong> ME: </strong>: " + message + "<br>";
              con.liveChatUI.innerHTML += "<strong> ME: </strong>: " + translatedMessage + "<br>";

              //Scroll chat and translated UI to bottom to keep focus on latest messages
              con.liveChatUIContainer.scrollTop = con.liveChatUIContainer.scrollHeight;
            }
          });
        }
      }

      function sendVoiceMessage(text) {
        if (text) {
          window.client.action(con.channel, text);

          //Print original message in Translated UI
          con.liveChatUI.innerHTML += "<strong> ME: </strong>: " + text + "<br>";

          //Print translated message in Chat UI
          con.liveChatUI.innerHTML += "<strong> ME: </strong>: " + text + "<br>";

          //Scroll chat and translated UI to bottom to keep focus on latest messages
          con.liveChatUIContainer.scrollTop = con.liveChatUIContainer.scrollHeight;
        }
      }

      /**************************Send Message****************************/

      /**************************Audio player****************************/
      function AudioPlayer() {
        //console.log('AudioPlayer()');
        // start listening on mic for streamer voice recognition, don't do TTS while streamer is speaking
        vr_function();
        var audioPlayer = document.createElement("audio");
        audioPlayer.setAttribute("id", "audioPlayer");
        document.body.appendChild(audioPlayer);

        var isSpeaking = false;
        var isPaused = false;
        var banRequested = false;
        var currentSpokenMessage = {};
        var banMessage = {};
        var lastQueuedMessage = {};

        var speaker = {
          self: this,
          messageQueue: [],
          Speak: async function (prefix, text, suffix, username, ssmlTextType, mID) {
            //console.log("Speaking: " + text + " -- with voice: " + voice);
            //If currently speaking a message, add new message to the messageQueue
            let message = {};
            message.prefix = prefix;
            message.suffix = suffix;
            message.text = text;
            message.username = username;
            message.ssmlTextType = ssmlTextType;
            message.messageID = mID;

            if (isSpeaking || streamerIsSpeaking || isPaused) {
              lastQueuedMessage = message;
              this.messageQueue.push(message);
            } else {
              speakMessage(message, false).then(speakNextMessage).catch(console.log);
            }
          },
          SpeakNow: async function (text, username, ssmlTextType, voice) {
            //console.log("Speaking: " + text + " -- with voice: " + voice);
            //If currently speaking a message, add new message to the messageQueue
            isSpeaking = true;
            let message = {};
            message.text = text;
            message.username = username;
            message.voice = voice;
            message.ssmlTextType = ssmlTextType;
            await speakMessage(message, true).then(speakNextMessage).catch(console.log);
          },
          SpeakNext: async function (text, username, ssmlTextType, voice, mID) {
            //console.log("Speaking: " + text + " -- with voice: " + voice);
            //If currently speaking a message, add new message to the messageQueue
            let message = {};
            message.text = text;
            message.username = username;
            message.voice = voice;
            message.ssmlTextType = ssmlTextType;
            message.messageID = mID;

            if (isSpeaking) {
              lastQueuedMessage = message;
              this.messageQueue.unshift(message);
            } else {
              speakMessage(message, false).then(speakNextMessage).catch(console.log);
            }
          },
          Pause: async function () {
            audioPlayer.pause();
            isPaused = true;
          },
          Continue: async function () {
            audioPlayer.play();
            isPaused = false;
            speakNextMessage();
          },
          Skip: async function () {
            audioPlayer.pause();
            const event = new Event("skip");
            audioPlayer.dispatchEvent(event);
            isSpeaking = false;
            speakNextMessage();
          },
          Dump: async function () {
            this.messageQueue = [];
            const event = new Event("skip");
            audioPlayer.dispatchEvent(event);
            isSpeaking = false;
          },
          PopLastMessage: async function (username) {
            for (var i = this.messageQueue.length - 1; i >= 0; i--) {
              if (username == this.messageQueue[i].username) {
                this.messageQueue.splice(i, 1);
                break;
              }
            }
          },
          PopAndGoFast: async function (username) {
            for (var i = this.messageQueue.length - 1; i >= 0; i--) {
              if (username == this.messageQueue[i].username) {
                this.messageQueue.splice(i, 1);
                break;
              }
            }
          },
          DumpByUser: async function (username) {
            this.messageQueue = this.messageQueue.filter(function (element) {
              return element.username != username;
            });
            const event = new Event("skip");
            audioPlayer.dispatchEvent(event);
            isSpeaking = false;
            speakNextMessage();
          },
          Ban: async function () {
            banMessage = currentSpokenMessage;
            audioPlayer.pause();

            let message = "Ban " + banMessage.username + "?";

            addSystemBubble(message, ++messageID);
            window.audioPlayer.SpeakNext(
              //"<speak>" + getSpokenName(document.getElementById("twitch_username").value) + " says " + text + "</speak>",
              message,
              "system",
              "text",
              messageID
            );
            currentSpokenMessage.banInitiated = true;
            banMessage.banInitiated = true;
          },
          BanConfirm: async function () {
            //console.log("BanConfirmed:", currentSpokenMessage, " channel:", con.channel);
            if (banMessage.banInitiated) {
              console.log("BanConfirmed:", banMessage, " channel:", con.channel);
              this.DumpByUser(banMessage.username);
              ttsBanByUser(con.channel, banMessage.username);
              window.audioPlayer.SpeakNow(
                //"<speak>" + getSpokenName(document.getElementById("twitch_username").value) + " says " + text + "</speak>",
                "Banned" + banMessage.username + ", hasta la vista, baby",
                "system",
                "text"
              );
              const event = new Event("skip");
              audioPlayer.dispatchEvent(event);
              isSpeaking = false;
              speakNextMessage();
              banMessage = {};
            }
          },
          BanCancel: async function () {
            if (banMessage.banInitiated) {
              let message = "You dodged a bullet there " + banMessage.username;
              addSystemBubble(message, ++messageID);
              window.audioPlayer.SpeakNext(
                //"<speak>" + getSpokenName(document.getElementById("twitch_username").value) + " says " + text + "</speak>",
                message,
                "system",
                "text",
                messageID
              );
              banMessage = {};

              //audioPlayer.play();
            }
          },
          BanConfirmLulz: async function () {
            //console.log("BanConfirmed:", currentSpokenMessage, " channel:", con.channel);
            if (banMessage.banInitiated) {
              isSpeaking = true;
              console.log("BanConfirmed:", banMessage, " channel:", con.channel);
              await this.DumpByUser(banMessage.username);
              await window.audioPlayer.SpeakNow(
                //"<speak>" + getSpokenName(document.getElementById("twitch_username").value) + " says " + text + "</speak>",
                '<speak>Get the <say-as interpret-as="expletive">fudge</say-as> out of here ' +
                  banMessage.username +
                  "</speak>",
                "system",
                "ssml"
              );

              var user = banMessage.username;
              ttsBanByUser(con.channel, user);

              setTimeout(function () {
                window.audioPlayer.SpeakNow(
                  //"<speak>" + getSpokenName(document.getElementById("twitch_username").value) + " says " + text + "</speak>",
                  "<speak>Just kidding " + user + ", we love you get back in here.</speak>",
                  "system",
                  "ssml"
                );
                ttsUnbanByUser(con.channel, user);
              }, 10000);

              isSpeaking = false;
              speakNextMessage();
              //
              banMessage = {};
            } else {
              console.log("BanConfirmed: ban not initiated", currentSpokenMessage, " channel:", con.channel);
              //audioPlayer.play();
            }
          },
        };

        // Speak text message
        async function speakMessage(message, immediate) {
          isSpeaking = true;
          if (!immediate) {
            currentSpokenMessage = message;
          }

          var prefix = {};
          var suffix = {};

          let originalBackground;
          let messageElement;

          if (message.messageID > 0) {
            messageElement = document.getElementById("message-user-id" + message.messageID);
            originalBackground = messageElement.style.backgroundColor;
            messageElement.style.backgroundColor = "green";
          }

          try {
            if (message.prefix) {
              prefix.text = message.prefix;
              prefix.username = "system";
              prefix.ssmlTextType = "ssml";
              prefix.messageID = message.messageID;
              await getPollyAudioStream(prefix).then(playAudioStream);
            }
          } catch (err) {
            console.log("speak prefix: catch(" + err + ")");
          }

          if (message.messageID > 0) {
            messageElement.style.backgroundColor = originalBackground;
            messageElement = document.getElementById("message-message-id" + message.messageID);
            originalBackground = messageElement.style.backgroundColor;
            messageElement.style.backgroundColor = "green";
          }

          let usefx = false;

          try {
            // /(.*?)?\s(?:with)?\s?([PU]\d+)(?:\s([PU]\d+))?(?:\s([PU]\d+))?(?:\s([PU]\d+))?/i
            // /(.*?)(?:\s+with)?\s+([pu]\d{1,3})$/i
            let match = message.text.match(
              /(.+?)(?:\swith)?\s(?:([pu]\d{1,3})\s?)(?:([pu]\d{1,3})\s?)?(?:([pu]\d{1,3})\s?)?(?:([pu]\d{1,3})\s?)?$/i
            );

            if (match && match[1]) {
              let presetCount = 1;
              usefx = true;
              message.text = match[1];

              let wsObject = {
                topic: "ttsfx",
                action: "fxSelect",
                time: Date.now(),
              };

              if (match[2]) {
                wsObject.preset1 = match[2].toLowerCase();
              }
              if (match[3]) {
                wsObject.preset2 = match[3].toLowerCase();
                presetCount++;
              }
              if (match[4]) {
                wsObject.preset3 = match[4].toLowerCase();
                presetCount++;
              }
              if (match[5]) {
                wsObject.preset4 = match[5].toLowerCase();
                presetCount++;
              }

              wsObject.presetCount = presetCount;

              websocketCustom.send(JSON.stringify(wsObject));
            }
          } catch (err) {
            console.log("send midi fxSelect: catch(" + err + ")");
          }

          await sleep(300);

          try {
            // Speak main part of message
            await getPollyAudioStream(message).then(playAudioStream);
          } catch (err) {
            console.log("speak main text: catch(" + err + ")");
          }

          try {
            if (usefx) {
              let wsObject = {
                topic: "ttsfx",
                action: "fxStop",
                time: Date.now(),
              };
              await sleep(1000);
              websocketCustom.send(JSON.stringify(wsObject));
            }
          } catch (err) {
            console.log("send midi fxStop: catch(" + err + ")");
          }

          try {
            if (message.suffix) {
              suffix.text = message.suffix;
              suffix.username = "system";
              suffix.ssmlTextType = "text";
              await getPollyAudioStream(suffix).then(playAudioStream);
            }
          } catch (err) {
            console.log("speak suffix catch: catch(" + err + ")");
          }

          if (message.messageID > 0) {
            messageElement.style.backgroundColor = originalBackground;
            messageElement = document.getElementById("message-user-id" + message.messageID);
            messageElement.style.backgroundColor = "black";
            messageElement = document.getElementById("message-message-id" + message.messageID);
            messageElement.style.backgroundColor = "black";
          }

          isSpeaking = false;
        }

        function sleep(duration) {
          return new Promise((resolve) => setTimeout(resolve, duration));
        }

        // Speak next message in the list
        function speakNextMessage() {
          if (!streamerIsSpeaking && !isSpeaking && !isPaused) {
            var queue = speaker.messageQueue;
            if (queue.length > 0) {
              var nextMessage = queue[0];
              queue.splice(0, 1);
              speakMessage(nextMessage).then(speakNextMessage).catch(console.log);
            }
          }
        }

        // Get synthesized speech from Amazon polly
        async function getPollyAudioStream(message) {
          //console.log("getPollyAudioStream:");
          //console.log(message);
          //console.trace();
          return new Promise(function (resolve, reject) {
            var polly = new AWS.Polly();

            var voice = "ivy";
            if (chatters[message.username] && chatters[message.username].hasOwnProperty("voice")) {
              voice = chatters[message.username].voice;
            }
            //console.log('voice: ' + voice);

            var engine = "standard";
            //console.log("Chatters:");
            //console.log(chatters);
            //console.log("Voices:");
            //console.log(voices);
            if (chatters[message.username] && chatters[message.username].hasOwnProperty("voice_option")) {
              engine = chatters[message.username].voice_option;
            } else {
              engine = voices[voice].voiceOptions[0];
            }

            if (message.username == "system") {
              voice = document.getElementById("systemVoice").value;
              engine = document.getElementById("systemVoiceOption").value;
              //messageElement = document.getElementById("message-system-voice-id" + message.messageID);
              //messageElement.innerHTML = `${voice} (${engine})`;
            } else if (message.username == "custom") {
              voice = message.voice.toLowerCase();
              engine = voices[voice].voiceOptions[0];
            } else {
              voice = voices[voice].name;
            }

            voice = voices[voice.toLocaleLowerCase()].name;

            var params = {
              OutputFormat: "mp3",
              Engine: engine,
              TextType: message.ssmlTextType,
              Text: message.text,
              VoiceId: voice,
            };
            //console.log('Speaking with:', params);

            polly.synthesizeSpeech(params, function (err, data) {
              if (err) {
                data = {};
                data.AudioStream = new Uint8Array(ssml_error);
              }
              resolve(data.AudioStream);
            });
          });
        }

        // Play audio stream
        function playAudioStream(audioStream) {
          //isSpeaking = true;
          return new Promise(function (resolve, reject) {
            //console.log(audioStream);
            //var uInt8Array = new Uint8Array(audioStream);
            var arrayBuffer = audioStream.buffer;
            var blob = new Blob([arrayBuffer]);
            var url = URL.createObjectURL(blob);
            audioPlayer.src = url;

            audioPlayer.addEventListener("ended", onEnded);
            audioPlayer.addEventListener("skip", onEnded);

            function onEnded() {
              //("onEnded:", arguments);
              audioPlayer.pause();
              audioPlayer.removeEventListener("ended", onEnded);
              audioPlayer.removeEventListener("skip", onEnded);

              // STOP MIDI FX

              resolve();
            }

            audioPlayer.play().catch(function (error) {
              console.log("audioPlayer error: " + JSON.stringify(error));
              reject(error);
            });
          });
        }

        /**************************Voice Recognition****************************/
        function vr_function() {
          if (
            document.getElementById("cbPauseTTSOnSpeech").checked ||
            document.getElementById("cbSendTextToWebsocket").checked
          ) {
            window.SpeechRecognition = window.SpeechRecognition || webkitSpeechRecognition;

            var recognition = new webkitSpeechRecognition();
            var speechStarted = Date.now();

            recognition.interimResults = true;
            recognition.continuous = true;

            //recognition.onspeechstart = function () {
            //  console.log("recognition.onspeechstart()");
            //};

            recognition.onend = function () {
              //console.log("recognition.onend()");
              setTimeout(function () {
                justWaitAMoment();
              }, 2000);

              streamerLastSpoke = Date.now();
              vr_function();
            };

            var trans_sourcelang = document.getElementById("dstLangSelect").value;
            var trans_destlang = document.getElementById("systemLangSelect").value;

            var gas_key = "AKfycbwi_joFMoaC8-kiSnvNiIfUqABbVar5Mg0g2nxu2BxuPkQiHJ5WwzYAFg";
            var TRANS_URL = "https://script.google.com/macros/s/" + gas_key + "/exec";
            var query = "";
            var request = new XMLHttpRequest();

            recognition.onresult = function (event) {
              if (
                !document.getElementById("cbSTTS").checked &&
                !document.getElementById("cbSendTextToWebsocket").checked
              ) {
                return;
              }
              //console.log('recognition.onresult()');
              var results = event.results;
              var speechProcessingStart = window.performance.now();

              for (var i = event.resultIndex; i < results.length; i++) {
                var text = results[i][0].transcript.trim();
                var confidence = results[i][0].confidence;
                if (results[i].isFinal) {
                  //console.log("onresult isFinal:", text);
                  runVoiceCommand(text);
                  sendTextToCCTPopup(text, true);

                  //console.log("final spoke for:", Date.now() - speechStarted);
                  //console.log("speechTimeQueue:", speechTimeQueue);
                  sendTextToCustomWebsocket(text, true, speechStarted, Date.now(), confidence);
                  sendTextToAWSWebsocket(text, true, speechStarted, Date.now(), confidence);

                  if (!document.getElementById("cbSTTS").checked) {
                    return;
                  }
                  // If source and dest lang match don't translate just speak
                  if (trans_sourcelang == trans_destlang) {
                    if (document.getElementById("cbSendDictationTranslation").checked) {
                      sendVoiceMessage(text);
                    }
                    addSystemBubble(text, ++messageID);
                    window.audioPlayer.Speak(
                      "",
                      //"<speak>" + getSpokenName(document.getElementById("twitch_username").value) + " says " + text + "</speak>",
                      text,
                      "",
                      "system",
                      "text",
                      messageID
                    );
                  } else {
                    if (gas_key != null) {
                      query =
                        TRANS_URL +
                        "?message=" +
                        results[i][0].transcript +
                        "&srcLang=" +
                        trans_sourcelang +
                        "&dstLang=" +
                        trans_destlang;
                      request.open("GET", query, true);

                      request.onreadystatechange = function () {
                        if (request.readyState === 4 && request.status === 200) {
                          //document.getElementById('speech_text-imb').innerHTML = recog_text;
                          //document.getElementById('trans_text-imb').innerHTML = request.responseText;
                          //window.audioPlayer.Speak("<speak>" + getSpokenName(document.getElementById("twitch_username").value) + " says </speak>", 'system', 'ssml');
                          if (document.getElementById("cbSendDictationTranslation").checked) {
                            sendVoiceMessage(text + " ( " + request.responseText + " ) confidence: " + confidence);
                          }
                          addSystemBubble(text, ++messageID);
                          window.audioPlayer.Speak("", request.responseText, "", "system", "text", messageID);

                          //window.audioPlayer.Speak(" translated from english.", 'system', 'text');
                        }
                      };
                      request.send(null);
                    }
                  }
                } else {
                  speechStarted = Date.now();
                  streamerSpeaking(true);
                  streamerLastSpoke = Date.now();

                  //console.log("interim now():", Date.now());
                  runImmediateVoiceCommand(text);
                  sendTextToCCTPopup(text, false);
                  sendTextToCustomWebsocket(text, false, speechStarted, Date.now());
                  //sendTextToAWSWebsocket(text, false);
                }
              }

              //console.log("processed results, wait to enable tts again");
              setTimeout(function () {
                justWaitAMoment();
              }, 3000);

              streamerLastSpoke = Date.now();

              //var time_diff = window.performance.now() - speechProcessingStart;
              //console.log("Speech processing took:", time_diff, "ms");
              //console.log("Speech processing took:", parseFloat(time_diff).toFixed(6), "ms");
            };

            recognition.start();
          } else {
            console.log("Pause TTS on speech disabled");
          }
        }

        function sendTextToCCTPopup(text, isFinal) {
          if (cctPopup != null && !cctPopup.closed) {
            //var lblFirstName = cctPopup.document.getElementById("lblFirstName");
            //var lblLastName = cctPopup.document.getElementById("lblLastName");
            //lblFirstName.innerHTML = document.getElementById("txtFirstName").value;
            //lblLastName.innerHTML = document.getElementById("txtLastName").value;
            cctPopup.focus();
          }
        }

        function sendTextToAWSWebsocket(text, isFinal, speechStarted, speechEnded, confidence) {
          if (
            document.getElementById("cbSendTextToAWSWebsocket").checked &&
            websocketProd &&
            websocketProd.readyState === WebSocket.OPEN
          ) {
            var wsObject = {
              action: "sendmessage",
              channel: con.channel,
              message: text,
              started: speechStarted,
              finished: speechEnded,
              confidence: confidence,
              time: Date.now(),
              isFinal: isFinal,
            };
            //console.log("sendTextToAWSWebsocket():", wsObject);
            websocketProd.send(JSON.stringify(wsObject));
          }
        }

        function sendTextToCustomWebsocket(text, isFinal, speechStarted, speechEnded, confidence) {
          if (
            document.getElementById("cbSendTextToWebsocket").checked &&
            websocketCustom &&
            websocketCustom.readyState === WebSocket.OPEN
          ) {
            var wsObject = {
              action: "spokenText",
              text: text,
              started: speechStarted,
              finished: speechEnded,
              confidence: confidence,
              time: Date.now(),
              isFinal: isFinal,
            };
            //console.log("sendTextToCustomWebsocket():", wsObject);
            //if (isFinal)
            websocketCustom.send(JSON.stringify(wsObject));
          }
        }

        function runImmediateVoiceCommand(text) {
          if (
            document.getElementById("cbPoofMessage").checked &&
            text.match(document.getElementById("txtPoofRegex").value)
          ) {
            console.log("poof");
            window.audioPlayer.Skip();
          } else if (text.toLowerCase().includes("wrap it up")) {
            window.audioPlayer.PopAndGoFast();
          }
        }

        function runVoiceCommand(text) {
          if (text.toLowerCase().includes("tts pause")) {
            window.audioPlayer.Pause();
          } else if (
            document.getElementById("cbBanHammer").checked &&
            text.match(document.getElementById("txtBanRegex").value)
          ) {
            console.log("ban");
            window.audioPlayer.Ban();
          } else if (
            document.getElementById("cbBanHammer").checked &&
            text.match(document.getElementById("txtBanConfirmRegex").value)
          ) {
            console.log("ban confirm");
            window.audioPlayer.BanConfirm();
          } else if (
            text.toLowerCase().includes("for the laws") ||
            text.toLowerCase().includes("for the lulz") ||
            text.toLowerCase().includes("for the lols") ||
            text.toLowerCase().includes("why not")
          ) {
            console.log("ban confirm lulz");
            window.audioPlayer.BanConfirmLulz();
          } else if (text.toLowerCase().includes("no")) {
            window.audioPlayer.BanCancel();
          } else if (text.toLowerCase().includes("tts continue")) {
            window.audioPlayer.Continue();
          } else if (text.toLowerCase().includes("tts dump") || text.toLowerCase().includes("tds dump")) {
            window.audioPlayer.Dump();
          }
        }

        function justWaitAMoment() {
          var lastSpokeDiff = Date.now() - streamerLastSpoke;
          //console.log("Last spoke diff: " + lastSpokeDiff);
          if (lastSpokeDiff >= 3000) {
            streamerSpeaking(false);
            //console.log("RELEASE THE KRAKEN!!!!!");
            speakNextMessage();
            //streamerLastSpoke = Date.now();
          }
        }

        function streamerSpeaking(speaking) {
          if (speaking) {
            streamerIsSpeaking = true;
            document.getElementById("title").innerHTML = "Security Live TTS Translator (TTS Paused - Speaking)";
          } else {
            streamerIsSpeaking = false;
            document.getElementById("title").innerHTML = "Security Live TTS Translator (TTS Enabled)";
          }
        }

        return speaker;
      }
      /**************************Audio player****************************/

      (async function () {
        //console.log('final load function()');
        await buildVoiceLookup();
        loadAndSortLanguages();

        Handlebars.registerHelper("contains", function (needle, haystack, options) {
          //needle = Handlebars.escapeExpression(needle);
          //haystack = Handlebars.escapeExpression(haystack);
          return haystack.indexOf(needle) > -1 ? options.fn(this) : options.inverse(this);
        });

        Handlebars.registerHelper("select", function (value, options) {
          var $el = $("<select />").html(options.fn(this));
          $el.find('[value="' + value + '"]').attr({ selected: "selected" });
          return $el.html();
        });

        var data = {};

        if (localStorage.getItem("systemVoice")) {
          data.voice = localStorage.getItem("systemVoice");
        } else {
          data.voice = "Justin";
        }

        data.voices = voicesDesc;

        var systemVoiceSource = document.getElementById("system-voice-template").innerHTML,
          systemVoiceTemplate = Handlebars.compile(systemVoiceSource),
          systemVoicePlaceholder = document.getElementById("systemVoicePlaceholder");

        systemVoicePlaceholder.innerHTML = systemVoiceTemplate(data);

        var systemVoiceOptionSource = document.getElementById("system-voice-option-template").innerHTML,
          systemVoiceOptionTemplate = Handlebars.compile(systemVoiceOptionSource),
          systemVoiceOptionPlaceholder = document.getElementById("systemVoiceOptionPlaceholder");

        var optionData = {};

        optionData.voiceOptions = voices[data.voice.toLowerCase()].voiceOptions;
        optionData.voiceOption = voices[data.voice.toLowerCase()].voiceOptions[0];

        systemVoiceOptionPlaceholder.innerHTML = systemVoiceOptionTemplate(optionData);

        if (localStorage.getItem("systemVoice")) {
          document.getElementById("systemVoice").value = localStorage.getItem("systemVoice");
        }
        if (localStorage.getItem("systemVoiceOption")) {
          document.getElementById("systemVoiceOption").value = localStorage.getItem("systemVoiceOption");
        }

        var srcLangSource = document.getElementById("lang-template").innerHTML,
          srcLangTemplate = Handlebars.compile(srcLangSource),
          srcLangPlaceholder = document.getElementById("srcLangPlaceholder");

        data = {};
        data.name = "Source Language Selection: (Keep auto unless you only want to translate only from one language) ";
        data.elementId = "srcLangSelect";
        data.langs = sortedLanguages;
        srcLangPlaceholder.innerHTML = srcLangTemplate(data);

        var dstLangSource = document.getElementById("lang-template").innerHTML,
          dstLangTemplate = Handlebars.compile(dstLangSource),
          dstLangPlaceholder = document.getElementById("dstLangPlaceholder");

        data.name = "Dest Language Selection: (Language to translate to) ";
        data.elementId = "dstLangSelect";
        dstLangPlaceholder.innerHTML = dstLangTemplate(data);

        var chatLangSource = document.getElementById("lang-template").innerHTML,
          chatLangTemplate = Handlebars.compile(chatLangSource),
          chatLangPlaceholder = document.getElementById("chatLangPlaceholder");

        data.name = "";
        data.elementId = "chatLangSelect";
        chatLangPlaceholder.innerHTML = chatLangTemplate(data);

        var systemLangSource = document.getElementById("lang-template").innerHTML,
          systemLangTemplate = Handlebars.compile(systemLangSource),
          systemLangPlaceholder = document.getElementById("systemLangPlaceholder");

        data.name = "System";
        data.elementId = "systemLangSelect";
        systemLangPlaceholder.innerHTML = systemLangTemplate(data);

        if (localStorage.getItem("srcLangSelect")) {
          document.getElementById("srcLangSelect").value = localStorage.getItem("srcLangSelect");
        } else {
          document.getElementById("srcLangSelect").value = "auto";
        }

        if (localStorage.getItem("dstLangSelect")) {
          document.getElementById("dstLangSelect").value = localStorage.getItem("dstLangSelect");
        } else {
          document.getElementById("dstLangSelect").value = "en";
        }
        if (localStorage.getItem("chatLangSelect")) {
          document.getElementById("chatLangSelect").value = localStorage.getItem("chatLangSelect");
        }
        if (localStorage.getItem("systemLangSelect")) {
          document.getElementById("systemLangSelect").value = localStorage.getItem("systemLangSelect");
        }

        if (access_token) {
          $("#login").hide();
          $("#ttsinfo").hide();
          $("#loggedin").show();
          if (autoconnect == "true") {
            connect();
          }
        } else {
          showAuthButton();
        }
      })();
    </script>
  </body>
</html>
